// alerts/vaultsTracker.jsimport "dotenv/config";import { sendTelegramMessage } from "../telegram.js";import { VAULTS } from "../vaultsConfig.js";const chatId = process.env.CHAT_ID;const ETHERSCAN_API_URL =  process.env.ETHERSCAN_API_URL || "https://api.etherscan.io/v2/api";const ETHERSCAN_API_KEY = process.env.ETHERSCAN_API_KEY;const CHAIN_ID = process.env.CHAIN_ID || "1";const CHECK_INTERVAL_SECONDS = parseInt(  process.env.CHECK_INTERVAL_SECONDS || "30",  10);const CHECK_EVERY_MS = CHECK_INTERVAL_SECONDS * 1000;// ‚è± timestamp de d√©marrage du process (pour ne jamais envoyer des tx "d'avant")const BOT_START_TS = Date.now();// pointeurs en m√©moire: key = vaultAddress -> "block:txIndex"const pointers = new Map();// anti-doublons: key = vaultAddress -> Set(hash)const seenHashes = new Map();// -------- Helpers --------function parseRows(raw) {  try {    if (!raw) return [];    if (Array.isArray(raw)) return raw;    if (Array.isArray(raw.result)) return raw.result;    if (raw && typeof raw === "object" && Array.isArray(raw.result)) {      return raw.result;    }  } catch (e) {}  return [];}// Parse "NNNN:LL" ‚Üí { have, block, index }function parsePointer(ptr) {  if (typeof ptr !== "string") {    return { have: false, block: 0, index: -1, raw: ptr, reason: "not_string" };  }  const m = /^(\d+):(\d+)$/.exec(ptr.trim());  if (!m) {    return { have: false, block: 0, index: -1, raw: ptr, reason: "bad_format" };  }  return {    have: true,    block: parseInt(m[1], 10),    index: parseInt(m[2], 10),    raw: ptr  };}function trimZeros(s) {  if (s.indexOf(".") === -1) return s;  s = s.replace(/0+$/, "");  if (s.endsWith(".")) s = s.slice(0, -1);  return s;}// -------- Etherscan calls --------// 1) Onglet "Transactions" (normal tx du vault)async function fetchNormalTxs(vault) {  if (!ETHERSCAN_API_KEY) {    throw new Error("ETHERSCAN_API_KEY missing in .env");  }  const url =    `${ETHERSCAN_API_URL}?chainid=${CHAIN_ID}` +    `&module=account&action=txlist` +    `&address=${vault.vaultAddress}` +    `&page=1&offset=100&sort=desc` +    `&apikey=${ETHERSCAN_API_KEY}`;  const res = await fetch(url);  if (!res.ok) {    console.error(      `‚ùå Etherscan HTTP error (txlist) for ${vault.name}:`,      res.status,      await res.text()    );    return [];  }  const json = await res.json();  return parseRows(json);}// 2) Token transfers pour (vaultAddress, tokenAddress)async function fetchTokenTxMap(vault) {  if (!ETHERSCAN_API_KEY) {    throw new Error("ETHERSCAN_API_KEY missing in .env");  }  const url =    `${ETHERSCAN_API_URL}?chainid=${CHAIN_ID}` +    `&module=account&action=tokentx` +    `&address=${vault.vaultAddress}` +    `&contractaddress=${vault.tokenAddress}` +    `&page=1&offset=100&sort=desc` +    `&apikey=${ETHERSCAN_API_KEY}`;  const res = await fetch(url);  if (!res.ok) {    console.error(      `‚ùå Etherscan HTTP error (tokentx) for ${vault.name}:`,      res.status,      await res.text()    );    return new Map();  }  const json = await res.json();  const rows = parseRows(json);  const TOKEN_ADDR_LC = vault.tokenAddress.toLowerCase();  const defaultDec = vault.tokenDecimals || 18;  const defaultSym = vault.tokenSymbol || "TOKEN";  // hash ‚Üí { total: BigInt, dec, sym }  const map = new Map();  for (const tx of rows) {    const ca = (tx.contractAddress || "").toLowerCase();    if (ca !== TOKEN_ADDR_LC) continue;    const hashLc = (tx.hash || "").toLowerCase();    if (!hashLc) continue;    const dec =      parseInt(tx.tokenDecimal || defaultDec, 10) || defaultDec;    const sym = tx.tokenSymbol || defaultSym;    const valueRaw = BigInt(tx.value || "0");    let entry = map.get(hashLc);    if (!entry) {      entry = { total: BigInt(0), dec, sym };    }    entry.total += valueRaw;    entry.dec = dec;    entry.sym = sym;    map.set(hashLc, entry);  }  return map;}// -------- Traitement d'un vault --------async function processVault(vault) {  const VAULT_ADDR_LC = vault.vaultAddress.toLowerCase();  const MIN_AMOUNT = vault.minAmount || 0;  const normalTxs = await fetchNormalTxs(vault);  const tokenMap = await fetchTokenTxMap(vault);  const key = VAULT_ADDR_LC;  const rawPtr = pointers.get(key) || "";  const p = parsePointer(rawPtr || "");  let seen = seenHashes.get(key);  if (!seen) {    seen = new Set();    seenHashes.set(key, seen);  }  const out = [];  for (const tx of normalTxs) {    // On ne garde que les tx r√©ussies    if (tx.isError && tx.isError !== "0") continue;    const from = (tx.from || "").toLowerCase();    const to = (tx.to || "").toLowerCase();    let type = null;    if (to === VAULT_ADDR_LC && from !== VAULT_ADDR_LC) {      type = "Deposit";    } else if (from === VAULT_ADDR_LC && to !== VAULT_ADDR_LC) {      type = "Withdraw";    } else {      // ce n'est pas un vrai in/out du vault (style interne) ‚Üí on ignore      continue;    }    const block = parseInt(tx.blockNumber, 10) || 0;    const ix = parseInt(tx.transactionIndex, 10) || 0;    const ts = Number(tx.timeStamp || "0") * 1000;    const hash = tx.hash || "";    const hashLc = hash.toLowerCase();    // Ne jamais envoyer de tx d'avant le d√©marrage du bot    if (ts < BOT_START_TS) continue;    // Baseline: tant qu'on n'a pas de pointeur, on n'envoie rien    if (!p.have) {      continue;    }    // "nouvelle" tx par rapport au pointeur txlist    const isNew =      block > p.block || (block === p.block && ix > p.index);    if (!isNew) continue;    // anti-doublon par hash pendant la vie du process    if (seen.has(hashLc)) continue;    const tokenInfo = tokenMap.get(hashLc);    if (!tokenInfo) {      // pas de transfer token pour cette tx ‚Üí on peut soit ignorer, soit envoyer sans montant      continue;    }    const dec = tokenInfo.dec;    const sym = tokenInfo.sym;    const amountNum = Number(tokenInfo.total) / Math.pow(10, dec);    if (amountNum < MIN_AMOUNT) continue;    const when = new Date(ts).toISOString();    const amountStr = trimZeros(amountNum.toFixed(Math.min(dec, 8)));    out.push({      block,      index: ix,      type,      symbol: sym,      amount: amountStr,      from,      to,      hash,      time: when    });    seen.add(hashLc);  }  // envoi dans l'ordre chronologique (ancien -> r√©cent)  out.sort((a, b) => {    if (a.block !== b.block) return a.block - b.block;    return a.index - b.index;  });  for (const it of out) {    const emoji = it.type === "Deposit" ? "üü¢" : "üî¥";    const msg =      `<b>${emoji} ${it.type} ${it.symbol}</b> on <b>${vault.name}</b>\n` +      `Amount: <b>${it.amount} ${it.symbol}</b>\n` +      `From: <code>${it.from}</code>\n` +      `To: <code>${it.to}</code>\n` +      `Date: ${it.time}\n` +      `Tx: https://etherscan.io/tx/${it.hash}`;    await sendTelegramMessage(chatId, msg);  }  // Mise √† jour du pointeur sur la base de la txlist (normalTxs tri√©s desc)  let newPointer = rawPtr || "";  if (normalTxs.length) {    const topBlock = parseInt(normalTxs[0].blockNumber, 10) || 0;    const topIx = parseInt(normalTxs[0].transactionIndex, 10) || 0;    newPointer = `${topBlock}:${topIx}`;  }  pointers.set(key, newPointer);  console.log(    "üîé Debug vault:",    JSON.stringify(      {        vault: vault.name,        pointerIn: rawPtr,        pointerValid: p.have,        newPointer,        newItems: out.length      },      null,      2    )  );}// -------- Boucle principale --------async function tickAllVaults() {  for (const vault of VAULTS) {    try {      await processVault(vault);    } catch (err) {      console.error(`‚ùå Error processing vault ${vault.name}:`, err);    }  }}export function startVaultsTracker() {  console.log(    `üöÄ gami-vaults-tracker-bot started (txlist + tokentx, no history). Check every ${CHECK_INTERVAL_SECONDS}s.`  );  // 1er passage = baseline silencieuse (p.have = false)  tickAllVaults();  setInterval(tickAllVaults, CHECK_EVERY_MS);}