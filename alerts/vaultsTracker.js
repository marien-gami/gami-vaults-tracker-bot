// alerts/vaultsTracker.jsimport "dotenv/config";import { sendTelegramMessage } from "../telegram.js";import { VAULTS } from "../vaultsConfig.js";const chatId = process.env.CHAT_ID;const ETHERSCAN_API_URL =  process.env.ETHERSCAN_API_URL || "https://api.etherscan.io/v2/api";const ETHERSCAN_API_KEY = process.env.ETHERSCAN_API_KEY;const CHAIN_ID = process.env.CHAIN_ID || "1";const CHECK_INTERVAL_SECONDS = parseInt(  process.env.CHECK_INTERVAL_SECONDS || "30",  10);const CHECK_EVERY_MS = CHECK_INTERVAL_SECONDS * 1000;// ‚è± timestamp de d√©marrage du process (pour ne jamais envoyer des tx "d'avant")const BOT_START_TS = Date.now();// pointeurs en m√©moire: key = vaultAddress -> "block:txIndex"const pointers = new Map();// anti-doublons: key = vaultAddress -> Set(hash)const seenHashes = new Map();// -------- Helpers --------// Adresse utilis√©e pour scanner les transferts de tokens// (controller si d√©fini, sinon vault)function getTokenScanAddress(vault) {  return vault.controllerAddress || vault.vaultAddress;}function parseRows(raw) {  try {    if (!raw) return [];    if (Array.isArray(raw)) return raw;    if (Array.isArray(raw.result)) return raw.result;    if (raw && typeof raw === "object" && Array.isArray(raw.result)) {      return raw.result;    }  } catch (e) {}  return [];}// Parse "NNNN:LL" ‚Üí { have, block, index }function parsePointer(ptr) {  if (typeof ptr !== "string") {    return { have: false, block: 0, index: -1, raw: ptr, reason: "not_string" };  }  const m = /^(\d+):(\d+)$/.exec(ptr.trim());  if (!m) {    return { have: false, block: 0, index: -1, raw: ptr, reason: "bad_format" };  }  return {    have: true,    block: parseInt(m[1], 10),    index: parseInt(m[2], 10),    raw: ptr  };}function trimZeros(s) {  if (s.indexOf(".") === -1) return s;  s = s.replace(/0+$/, "");  if (s.endsWith(".")) s = s.slice(0, -1);  return s;}// -------- Etherscan calls --------// 1) Onglet "Transactions" (normal tx) pour l'adresse du VAULT//    -> utilis√© pour d√©tecter les nouvelles tx + pointeursasync function fetchNormalTxs(vault) {  if (!ETHERSCAN_API_KEY) {    throw new Error("ETHERSCAN_API_KEY missing in .env");  }  const url =    `${ETHERSCAN_API_URL}?chainid=${CHAIN_ID}` +    `&module=account&action=txlist` +    `&address=${vault.vaultAddress}` +    `&page=1&offset=100&sort=desc` +    `&apikey=${ETHERSCAN_API_KEY}`;  const res = await fetch(url);  if (!res.ok) {    console.error(      `‚ùå Etherscan HTTP error (txlist) for ${vault.name}:`,      res.status,      await res.text()    );    return [];  }  const json = await res.json();  return parseRows(json);}// 2) Token transfers pour (tokenScanAddress, tokenAddress)//    -> utilis√© pour r√©cup√©rer les montants des d√©p√¥ts/retraitsasync function fetchTokenTxMap(vault) {  if (!ETHERSCAN_API_KEY) {    throw new Error("ETHERSCAN_API_KEY missing in .env");  }  const TOKEN_SCAN_ADDR = getTokenScanAddress(vault);  const TOKEN_SCAN_ADDR_LC = TOKEN_SCAN_ADDR.toLowerCase();  const url =    `${ETHERSCAN_API_URL}?chainid=${CHAIN_ID}` +    `&module=account&action=tokentx` +    `&address=${TOKEN_SCAN_ADDR}` +    `&contractaddress=${vault.tokenAddress}` +    `&page=1&offset=100&sort=desc` +    `&apikey=${ETHERSCAN_API_KEY}`;  const res = await fetch(url);  if (!res.ok) {    console.error(      `‚ùå Etherscan HTTP error (tokentx) for ${vault.name}:`,      res.status,      await res.text()    );    return new Map();  }  const json = await res.json();  const rows = parseRows(json);  const TOKEN_ADDR_LC = vault.tokenAddress.toLowerCase();  const defaultDec = vault.tokenDecimals || 18;  const defaultSym = vault.tokenSymbol || "TOKEN";  // hash ‚Üí { in: BigInt, out: BigInt, dec, sym }  const map = new Map();  for (const tx of rows) {    const ca = (tx.contractAddress || "").toLowerCase();    if (ca !== TOKEN_ADDR_LC) continue;    const hashLc = (tx.hash || "").toLowerCase();    if (!hashLc) continue;    const dec = parseInt(tx.tokenDecimal || defaultDec, 10) || defaultDec;    const sym = tx.tokenSymbol || defaultSym;    const valueRaw = BigInt(tx.value || "0");    const fromLc = (tx.from || "").toLowerCase();    const toLc = (tx.to || "").toLowerCase();    let entry = map.get(hashLc);    if (!entry) {      entry = { in: BigInt(0), out: BigInt(0), dec, sym };    }    // On s√©pare les flux par rapport √† TOKEN_SCAN_ADDR :    // - "in"  = tokens qui arrivent sur TOKEN_SCAN_ADDR    // - "out" = tokens qui sortent de TOKEN_SCAN_ADDR    if (toLc === TOKEN_SCAN_ADDR_LC) {      entry.in += valueRaw;    }    if (fromLc === TOKEN_SCAN_ADDR_LC) {      entry.out += valueRaw;    }    entry.dec = dec;    entry.sym = sym;    map.set(hashLc, entry);  }  return map;}// -------- Traitement d'un vault --------async function processVault(vault) {  const VAULT_ADDR_LC = vault.vaultAddress.toLowerCase();  const TOKEN_SCAN_ADDR = getTokenScanAddress(vault);  const MIN_AMOUNT = vault.minAmount || 0;  const normalTxs = await fetchNormalTxs(vault);  const tokenMap = await fetchTokenTxMap(vault);  const key = VAULT_ADDR_LC; // pointeur par vault logique  const rawPtr = pointers.get(key) || "";  const p = parsePointer(rawPtr || "");  let seen = seenHashes.get(key);  if (!seen) {    seen = new Set();    seenHashes.set(key, seen);  }  const out = [];  for (const tx of normalTxs) {    // On ne garde que les tx r√©ussies    if (tx.isError && tx.isError !== "0") continue;    const from = (tx.from || "").toLowerCase();    const to = (tx.to || "").toLowerCase();    // Type bas√© UNIQUEMENT sur le VAULT (adresse logique)    let type = null;    if (to === VAULT_ADDR_LC && from !== VAULT_ADDR_LC) {      type = "Deposit";    } else if (from === VAULT_ADDR_LC && to !== VAULT_ADDR_LC) {      type = "Withdraw";    } else {      // pas un vrai in/out du vault ‚Üí on ignore      continue;    }    const block = parseInt(tx.blockNumber, 10) || 0;    const ix = parseInt(tx.transactionIndex, 10) || 0;    const ts = Number(tx.timeStamp || "0") * 1000;    const hash = tx.hash || "";    const hashLc = hash.toLowerCase();    // Ne jamais envoyer de tx d'avant le d√©marrage du bot    if (ts < BOT_START_TS) continue;    // On consid√®re une tx "nouvelle" si :    // - pas encore de pointeur, OU    // - block/index > pointeur    const isNew =      !p.have ||      block > p.block ||      (block === p.block && ix > p.index);    if (!isNew) continue;    // anti-doublon par hash pendant la vie du process    if (seen.has(hashLc)) continue;    const tokenInfo = tokenMap.get(hashLc);    if (!tokenInfo) {      // pas de transfert du token cible pour cette tx      continue;    }    const dec = tokenInfo.dec;    const sym = tokenInfo.sym;    // Montant en fonction du type :    // - Deposit  => flux entrant sur TOKEN_SCAN_ADDR    // - Withdraw => flux sortant de TOKEN_SCAN_ADDR    let rawAmount = BigInt(0);    if (type === "Deposit") {      rawAmount = tokenInfo.in;    } else if (type === "Withdraw") {      rawAmount = tokenInfo.out;    }    if (rawAmount <= 0n) continue;    const amountNum = Number(rawAmount) / Math.pow(10, dec);    if (amountNum < MIN_AMOUNT) continue;    const when = new Date(ts).toISOString();    const amountStr = trimZeros(      amountNum.toFixed(Math.min(dec, 8))    );    out.push({      block,      index: ix,      type,      symbol: sym,      amount: amountStr,      from,      to,      hash,      time: when    });    seen.add(hashLc);  }  // envoi dans l'ordre chronologique (ancien -> r√©cent)  out.sort((a, b) => {    if (a.block !== b.block) return a.block - b.block;    return a.index - b.index;  });  for (const it of out) {    const emoji = it.type === "Deposit" ? "üü¢" : "üî¥";    const msg =      `<b>${emoji} ${it.type} ${it.symbol}</b> on <b>${vault.name}</b>\n` +      `Amount: <b>${it.amount} ${it.symbol}</b>\n` +      `From: <code>${it.from}</code>\n` +      `To: <code>${it.to}</code>\n` +      `Date: ${it.time}\n` +      `Tx: https://etherscan.io/tx/${it.hash}`;    await sendTelegramMessage(chatId, msg);  }  // Mise √† jour du pointeur sur la base de la txlist (normalTxs tri√©s desc)  let newPointer = rawPtr || "";  if (normalTxs.length) {    const topBlock = parseInt(normalTxs[0].blockNumber, 10) || 0;    const topIx = parseInt(normalTxs[0].transactionIndex, 10) || 0;    newPointer = `${topBlock}:${topIx}`;  }  pointers.set(key, newPointer);  console.log(    "üîé Debug vault:",    JSON.stringify(      {        vault: vault.name,        vaultAddress: vault.vaultAddress,        tokenScanAddress: TOKEN_SCAN_ADDR,        pointerIn: rawPtr,        pointerValid: p.have,        newPointer,        newItems: out.length      },      null,      2    )  );}// -------- Boucle principale --------async function tickAllVaults() {  for (const vault of VAULTS) {    try {      await processVault(vault);    } catch (err) {      console.error(`‚ùå Error processing vault ${vault.name}:`, err);    }  }}export function startVaultsTracker() {  console.log(    `üöÄ gami-vaults-tracker-bot started (txlist on vaultAddress + tokentx on controller/vault, no history before start). Check every ${CHECK_INTERVAL_SECONDS}s.`  );  tickAllVaults();  setInterval(tickAllVaults, CHECK_EVERY_MS);}