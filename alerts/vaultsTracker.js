// alerts/vaultsTracker.jsimport "dotenv/config";import { sendTelegramMessage } from "../telegram.js";import { VAULTS } from "../vaultsConfig.js";const chatId = process.env.CHAT_ID;const ETHERSCAN_API_URL =  process.env.ETHERSCAN_API_URL || "https://api.etherscan.io/v2/api";const ETHERSCAN_API_KEY = process.env.ETHERSCAN_API_KEY;const CHAIN_ID = process.env.CHAIN_ID || "1";const CHECK_INTERVAL_SECONDS = parseInt(  process.env.CHECK_INTERVAL_SECONDS || "30",  10);const CHECK_EVERY_MS = CHECK_INTERVAL_SECONDS * 1000;// timestamp de d√©marrage du process (√©vite d'envoyer des tx "anciennes")const BOT_START_TS = Date.now();// pointeurs en m√©moire: key = "vaultAddr-tokenAddr" ‚Üí "block:logIndex"const pointers = new Map();// -------- Helpers --------function parseRows(raw) {  try {    if (!raw) return [];    if (Array.isArray(raw)) return raw;    if (Array.isArray(raw.result)) return raw.result;    if (raw && typeof raw === "object" && Array.isArray(raw.result)) {      return raw.result;    }  } catch (e) {}  return [];}// Parse "NNNN:LL" ‚Üí { have, block, log }function parsePointer(ptr) {  if (typeof ptr !== "string") {    return { have: false, block: 0, log: -1, raw: ptr, reason: "not_string" };  }  const m = /^(\d+):(\d+)$/.exec(ptr.trim());  if (!m) {    return { have: false, block: 0, log: -1, raw: ptr, reason: "bad_format" };  }  return {    have: true,    block: parseInt(m[1], 10),    log: parseInt(m[2], 10),    raw: ptr  };}// Index fiable: logIndex si dispo, sinon transactionIndexfunction safeIndex(tx) {  let ix = tx && tx.logIndex;  if (    ix === undefined ||    ix === null ||    ix === "" ||    isNaN(parseInt(ix, 10))  ) {    ix = tx && tx.transactionIndex;  }  ix = parseInt(ix, 10);  if (isNaN(ix)) ix = 0;  return ix;}function trimZeros(s) {  if (s.indexOf(".") === -1) return s;  s = s.replace(/0+$/, "");  if (s.endsWith(".")) s = s.slice(0, -1);  return s;}// -------- Etherscan calls --------// Onglet "Transactions" du vault : txlistasync function fetchNormalTxs(vault) {  if (!ETHERSCAN_API_KEY) {    throw new Error("ETHERSCAN_API_KEY missing in .env");  }  const address = vault.vaultAddress;  const url =    `${ETHERSCAN_API_URL}?chainid=${CHAIN_ID}` +    `&module=account&action=txlist` +    `&address=${address}` +    `&page=1&offset=100&sort=desc` +    `&apikey=${ETHERSCAN_API_KEY}`;  const res = await fetch(url);  if (!res.ok) {    console.error(      `‚ùå Etherscan HTTP error (txlist) for ${vault.name}:`,      res.status,      await res.text()    );    return [];  }  const json = await res.json();  return parseRows(json);}// Transferts ERC-20 (tokenAddress) li√©s au vault : tokentxasync function fetchTokenTxs(vault) {  if (!ETHERSCAN_API_KEY) {    throw new Error("ETHERSCAN_API_KEY missing in .env");  }  const address = vault.vaultAddress;  const token = vault.tokenAddress;  const url =    `${ETHERSCAN_API_URL}?chainid=${CHAIN_ID}` +    `&module=account&action=tokentx` +    `&address=${address}` +    `&contractaddress=${token}` +    `&page=1&offset=100&sort=desc` +    `&apikey=${ETHERSCAN_API_KEY}`;  const res = await fetch(url);  if (!res.ok) {    console.error(      `‚ùå Etherscan HTTP error (tokentx) for ${vault.name}:`,      res.status,      await res.text()    );    return [];  }  const json = await res.json();  return parseRows(json);}// -------- Traitement d'un vault --------async function processVault(vault) {  const WATCH_ADDR_LC = vault.vaultAddress.toLowerCase();  const TOKEN_ADDR_LC = vault.tokenAddress.toLowerCase();  const TOKEN_DEFAULT_DECIMALS = vault.tokenDecimals || 18;  const MIN_AMOUNT = vault.minAmount || 0;  const TOKEN_SYMBOL = vault.tokenSymbol || "TOKEN";  // 1Ô∏è‚É£ On r√©cup√®re les tx "Transactions" du vault  const normalTxs = await fetchNormalTxs(vault);  const normalHashes = new Set(    normalTxs      .map((tx) => (tx.hash || "").toLowerCase())      .filter((h) => h.length > 0)  );  // 2Ô∏è‚É£ On r√©cup√®re les transferts de token  const rows = await fetchTokenTxs(vault);  const key = `${WATCH_ADDR_LC}-${TOKEN_ADDR_LC}`;  const rawPtr = pointers.get(key) || "";  const p = parsePointer(rawPtr || "");  const out = [];  for (const tx of rows) {    const ca = (tx.contractAddress || "").toLowerCase();    if (ca !== TOKEN_ADDR_LC) continue;    const from = (tx.from || "").toLowerCase();    const to = (tx.to || "").toLowerCase();    // Transformations relatives au vault    let type = null;    if (to === WATCH_ADDR_LC && from !== WATCH_ADDR_LC) {      type = "Deposit";    } else if (from === WATCH_ADDR_LC && to !== WATCH_ADDR_LC) {      type = "Withdraw";    } else {      // self-transfer ou truc interne entre vaults/strats ‚Üí on ignore      continue;    }    const hash = (tx.hash || "").toLowerCase();    // üîí Filtre "Transactions" tab :    // on ne garde que les transferts dont le hash est dans la txlist du vault    if (!normalHashes.has(hash)) {      continue;    }    const block = parseInt(tx.blockNumber, 10) || 0;    const ix = safeIndex(tx);    // ‚õîÔ∏è 1er run: pas de pointeur valide => on n'envoie rien    const isNew =      p.have && (block > p.block || (block === p.block && ix > p.log));    if (!isNew) continue;    const dec =      parseInt(tx.tokenDecimal || TOKEN_DEFAULT_DECIMALS, 10) ||      TOKEN_DEFAULT_DECIMALS;    const sym = tx.tokenSymbol || TOKEN_SYMBOL;    const amountNum = Number(tx.value || "0") / Math.pow(10, dec);    if (amountNum < MIN_AMOUNT) continue;    const ts = Number(tx.timeStamp || "0") * 1000;    // ‚è± s√©curit√© : ne jamais envoyer de tx d'avant le d√©marrage du bot    if (ts < BOT_START_TS) continue;    const when = new Date(ts).toISOString();    const amountStr = trimZeros(amountNum.toFixed(Math.min(dec, 8)));    out.push({      uid: `${block}:${ix}`,      type,      symbol: sym,      amount: amountStr,      from,      to,      hash: tx.hash,      time: when    });  }  // Tri ancien -> r√©cent (pour envoyer dans l'ordre)  out.sort((a, b) => {    const [ab, al] = a.uid.split(":").map((x) => parseInt(x, 10));    const [bb, bl] = b.uid.split(":").map((x) => parseInt(x, 10));    if (ab !== bb) return ab - bb;    return al - bl;  });  // Mise √† jour du pointeur sur la base des transferts token (rows tri√©s desc)  let newPointer = rawPtr || "";  if (rows.length) {    const topBlock = parseInt(rows[0].blockNumber, 10) || 0;    let maxIx = 0;    for (const r of rows) {      const b = parseInt(r.blockNumber, 10) || 0;      if (b !== topBlock) break; // rows tri√©s desc      const sIx = safeIndex(r);      if (sIx > maxIx) maxIx = sIx;    }    newPointer = `${topBlock}:${maxIx}`;  }  pointers.set(key, newPointer);  // Envoi Telegram  for (const it of out) {    const emoji = it.type === "Deposit" ? "üü¢" : "üî¥";    const msg =      `<b>${emoji} ${it.type} ${it.symbol}</b> on <b>${vault.name}</b>\n` +      `Amount: <b>${it.amount} ${it.symbol}</b>\n` +      `From: <code>${it.from}</code>\n` +      `To: <code>${it.to}</code>\n` +      `Date: ${it.time}\n` +      `Tx: https://etherscan.io/tx/${it.hash}`;    await sendTelegramMessage(chatId, msg);  }  console.log(    "üîé Debug vault:",    JSON.stringify(      {        vault: vault.name,        pointerIn: rawPtr,        pointerValid: p.have,        newPointer,        newItems: out.length      },      null,      2    )  );}// -------- Boucle principale --------async function tickAllVaults() {  for (const vault of VAULTS) {    try {      await processVault(vault);    } catch (err) {      console.error(`‚ùå Error processing vault ${vault.name}:`, err);    }  }}export function startVaultsTracker() {  console.log(    `üöÄ gami-vaults-tracker-bot started (txlist + tokentx). Check every ${CHECK_INTERVAL_SECONDS}s.`  );  // 1er passage = baseline silencieuse  tickAllVaults();  setInterval(tickAllVaults, CHECK_EVERY_MS);}