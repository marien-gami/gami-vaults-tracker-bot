// alerts/vaultsTracker.jsimport "dotenv/config";import { sendTelegramMessage } from "../telegram.js";import { VAULTS } from "../vaultsConfig.js";const chatId = process.env.CHAT_ID;const ETHERSCAN_API_URL =  process.env.ETHERSCAN_API_URL || "https://api.etherscan.io/v2/api";const ETHERSCAN_API_KEY = process.env.ETHERSCAN_API_KEY;const CHAIN_ID = process.env.CHAIN_ID || "1";const CHECK_INTERVAL_SECONDS = parseInt(  process.env.CHECK_INTERVAL_SECONDS || "30",  10);const CHECK_EVERY_MS = CHECK_INTERVAL_SECONDS * 1000;// petit throttle pour √©viter les rate limits Etherscanconst ETHERSCAN_DELAY_MS = parseInt(  process.env.ETHERSCAN_DELAY_MS || "600",  10);// ‚è± timestamp de d√©marrage du process (pour ne jamais envoyer des tx "d'avant")const BOT_START_TS = Date.now();// pointeurs en m√©moire: key = vaultAddress -> "block:txIndex"const pointers = new Map();// anti-doublons: key = vaultAddress -> Set(hash)const seenHashes = new Map();// -------- Helpers --------// Adresse utilis√©e pour scanner les transferts de tokens// (controller si d√©fini, sinon vault)function getTokenScanAddress(vault) {  return vault.controllerAddress || vault.vaultAddress;}function parseRows(raw) {  try {    if (!raw) return [];    if (Array.isArray(raw)) return raw;    if (Array.isArray(raw.result)) return raw.result;    if (raw && typeof raw === "object" && Array.isArray(raw.result)) {      return raw.result;    }  } catch (e) {}  return [];}// Parse "NNNN:LL" ‚Üí { have, block, index }function parsePointer(ptr) {  if (typeof ptr !== "string") {    return { have: false, block: 0, index: -1, raw: ptr, reason: "not_string" };  }  const m = /^(\d+):(\d+)$/.exec(ptr.trim());  if (!m) {    return { have: false, block: 0, index: -1, raw: ptr, reason: "bad_format" };  }  return {    have: true,    block: parseInt(m[1], 10),    index: parseInt(m[2], 10),    raw: ptr  };}function trimZeros(s) {  if (s.indexOf(".") === -1) return s;  s = s.replace(/0+$/, "");  if (s.endsWith(".")) s = s.slice(0, -1);  return s;}function sleep(ms) {  return new Promise((resolve) => setTimeout(resolve, ms));}// -------- Etherscan: tokentx only --------// R√©cup√®re les transferts ERC20 pour tokenScanAddress + tokenAddress,// et regroupe par hash: on obtient un "event" par transaction.async function fetchTokenEvents(vault) {  if (!ETHERSCAN_API_KEY) {    throw new Error("ETHERSCAN_API_KEY missing in .env");  }  const TOKEN_SCAN_ADDR = getTokenScanAddress(vault);  const TOKEN_SCAN_ADDR_LC = TOKEN_SCAN_ADDR.toLowerCase();  const url =    `${ETHERSCAN_API_URL}?chainid=${CHAIN_ID}` +    `&module=account&action=tokentx` +    `&address=${TOKEN_SCAN_ADDR}` +    `&contractaddress=${vault.tokenAddress}` +    `&page=1&offset=100&sort=desc` +    `&apikey=${ETHERSCAN_API_KEY}`;  // throttle simple pour limiter les erreurs "Max rate limit"  await sleep(ETHERSCAN_DELAY_MS);  const res = await fetch(url);  if (!res.ok) {    console.error(      `‚ùå Etherscan HTTP error (tokentx) for ${vault.name}:`,      res.status,      await res.text()    );    return [];  }  const json = await res.json();  // Etherscan v2: status: "1" = OK, "0" = NOTOK  if (!json || json.status !== "1" || !Array.isArray(json.result)) {    console.error(      `‚ö†Ô∏è Etherscan logical error (tokentx) for ${vault.name}:`,      json && json.message,      json && json.result    );    return [];  }  const rows = parseRows(json);  const TOKEN_ADDR_LC = vault.tokenAddress.toLowerCase();  const defaultDec = vault.tokenDecimals || 18;  const defaultSym = vault.tokenSymbol || "TOKEN";  // hash ‚Üí event agr√©g√©  const map = new Map();  for (const tx of rows) {    const ca = (tx.contractAddress || "").toLowerCase();    if (ca !== TOKEN_ADDR_LC) continue;    const hash = tx.hash || "";    const hashLc = hash.toLowerCase();    if (!hashLc) continue;    const blockNumber = parseInt(tx.blockNumber, 10) || 0;    const txIndex = parseInt(tx.transactionIndex, 10) || 0;    const tsMs = Number(tx.timeStamp || "0") * 1000;    const fn = (tx.functionName || "").toLowerCase();    const dec = parseInt(tx.tokenDecimal || defaultDec, 10) || defaultDec;    const sym = tx.tokenSymbol || defaultSym;    const valueRaw = BigInt(tx.value || "0");    const fromLc = (tx.from || "").toLowerCase();    const toLc = (tx.to || "").toLowerCase();    let ev = map.get(hashLc);    if (!ev) {      ev = {        hash,        blockNumber,        txIndex,        timeMs: tsMs,        functionName: fn,        in: 0n,        out: 0n,        dec,        sym,        depositSender: null,        withdrawRecipient: null      };    } else {      // m√™me tx: on garde les max pour s√©curit√©      if (blockNumber > ev.blockNumber) ev.blockNumber = blockNumber;      if (txIndex > ev.txIndex) ev.txIndex = txIndex;      if (tsMs > ev.timeMs) ev.timeMs = tsMs;      if (fn && !ev.functionName) ev.functionName = fn;    }    // flux entrant vers tokenScanAddress    if (toLc === TOKEN_SCAN_ADDR_LC) {      ev.in += valueRaw;      if (!ev.depositSender) ev.depositSender = fromLc;    }    // flux sortant depuis tokenScanAddress    if (fromLc === TOKEN_SCAN_ADDR_LC) {      ev.out += valueRaw;      if (!ev.withdrawRecipient) ev.withdrawRecipient = toLc;    }    ev.dec = dec;    ev.sym = sym;    map.set(hashLc, ev);  }  // Array d'events agr√©g√©s  return Array.from(map.values());}// -------- Traitement d'un vault --------async function processVault(vault) {  const VAULT_ADDR_LC = vault.vaultAddress.toLowerCase();  const TOKEN_SCAN_ADDR = getTokenScanAddress(vault);  const MIN_AMOUNT = vault.minAmount || 0;  const events = await fetchTokenEvents(vault);  const key = VAULT_ADDR_LC; // pointeur par vault logique  const rawPtr = pointers.get(key) || "";  const p = parsePointer(rawPtr || "");  let seen = seenHashes.get(key);  if (!seen) {    seen = new Set();    seenHashes.set(key, seen);  }  const out = [];  for (const ev of events) {    const block = ev.blockNumber || 0;    const ix = ev.txIndex || 0;    const ts = ev.timeMs || 0;    const hash = ev.hash || "";    const hashLc = hash.toLowerCase();    // Ne jamais envoyer de tx d'avant le d√©marrage du bot    if (ts < BOT_START_TS) continue;    // Si on a d√©j√† un pointeur, on ne garde que ce qui est strictement apr√®s    if (p.have) {      const isNew =        block > p.block || (block === p.block && ix > p.index);      if (!isNew) continue;    }    // anti-doublon par hash pendant la vie du process    if (seen.has(hashLc)) continue;    const dec = ev.dec;    const sym = ev.sym;    const fnLower = (ev.functionName || "").toLowerCase();    // D√©termination du type Deposit / Withdraw    let type = null;    // 1) Sur le nom de la fonction quand possible    if (fnLower.includes("deposit")) {      type = "Deposit";    } else if (fnLower.includes("withdraw") || fnLower.includes("redeem")) {      type = "Withdraw";    } else {      // 2) Fallback sur les flux net      if (ev.in > 0n && ev.out === 0n) {        type = "Deposit";      } else if (ev.out > 0n && ev.in === 0n) {        type = "Withdraw";      }    }    if (!type) continue;    // Montant & from/to "token"    let rawAmount = 0n;    let from = "";    let to = "";    if (type === "Deposit") {      rawAmount = ev.in;      from = ev.depositSender || "";      to = TOKEN_SCAN_ADDR.toLowerCase();    } else {      rawAmount = ev.out;      from = TOKEN_SCAN_ADDR.toLowerCase();      to = ev.withdrawRecipient || "";    }    if (rawAmount <= 0n) continue;    const amountNum = Number(rawAmount) / Math.pow(10, dec);    if (amountNum < MIN_AMOUNT) continue;    const whenIso = new Date(ts).toISOString();    const amountStr = trimZeros(      amountNum.toFixed(Math.min(dec, 8))    );    out.push({      block,      index: ix,      type,      symbol: sym,      amount: amountStr,      from,      to,      hash,      time: whenIso    });    seen.add(hashLc);  }  // envoi dans l'ordre chronologique (ancien -> r√©cent)  out.sort((a, b) => {    if (a.block !== b.block) return a.block - b.block;    return a.index - b.index;  });  for (const it of out) {    const emoji = it.type === "Deposit" ? "üü¢" : "üî¥";    const msg =      `<b>${emoji} ${it.type} ${it.symbol}</b> on <b>${vault.name}</b>\n` +      `Amount: <b>${it.amount} ${it.symbol}</b>\n` +      (it.from        ? `From: <code>${it.from}</code>\n`        : "") +      (it.to        ? `To: <code>${it.to}</code>\n`        : "") +      `Date: ${it.time}\n` +      `Tx: https://etherscan.io/tx/${it.hash}`;    await sendTelegramMessage(chatId, msg);  }  // Mise √† jour du pointeur sur la base des events tokentx (API renvoie d√©j√† tri√© desc)  let newPointer = rawPtr || "";  if (events.length) {    // events vient de Etherscan avec sort=desc -> events[0] est le plus r√©cent    const top = events[0];    newPointer = `${top.blockNumber || 0}:${top.txIndex || 0}`;  }  pointers.set(key, newPointer);  console.log(    "üîé Debug vault:",    JSON.stringify(      {        vault: vault.name,        vaultAddress: vault.vaultAddress,        tokenScanAddress: TOKEN_SCAN_ADDR,        pointerIn: rawPtr,        pointerValid: p.have,        newPointer,        newItems: out.length      },      null,      2    )  );}// -------- Boucle principale --------async function tickAllVaults() {  for (const vault of VAULTS) {    try {      await processVault(vault);    } catch (err) {      console.error(`‚ùå Error processing vault ${vault.name}:`, err);    }  }}export function startVaultsTracker() {  console.log(    `üöÄ gami-vaults-tracker-bot started (tokentx only, baseline = no history before start). Check every ${CHECK_INTERVAL_SECONDS}s.`  );  // 1er passage: si des tx ont eu lieu apr√®s le d√©marrage, elles partent;  // celles d'avant sont filtr√©es par BOT_START_TS.  tickAllVaults();  setInterval(tickAllVaults, CHECK_EVERY_MS);}