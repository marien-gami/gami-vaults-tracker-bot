// alerts/vaultsTracker.jsimport "dotenv/config";import { sendTelegramMessage } from "../telegram.js";import { VAULTS } from "../vaultsConfig.js";const chatId = process.env.CHAT_ID;const ETHERSCAN_API_URL =  process.env.ETHERSCAN_API_URL || "https://api.etherscan.io/v2/api";const ETHERSCAN_API_KEY = process.env.ETHERSCAN_API_KEY;const CHAIN_ID = process.env.CHAIN_ID || "1";const CHECK_INTERVAL_SECONDS = parseInt(process.env.CHECK_INTERVAL_SECONDS || "30", 10);const CHECK_EVERY_MS = CHECK_INTERVAL_SECONDS * 1000;// Pointeurs en m√©moire: key = "vaultAddr-tokenAddr" ‚Üí "block:log"const pointers = new Map();// -------- Helpers (adapt√©s de ton code Zapier) --------function parseRows(raw) {  try {    if (!raw) return [];    if (Array.isArray(raw)) return raw;    if (Array.isArray(raw.result)) return raw.result;    if (raw && typeof raw === "object" && Array.isArray(raw.result)) return raw.result;  } catch (e) {}  return [];}// Parse "NNNN:LL" ‚Üí { have, block, log }function parsePointer(ptr) {  if (typeof ptr !== "string") {    return { have: false, block: 0, log: -1, raw: ptr, reason: "not_string" };  }  const m = /^(\d+):(\d+)$/.exec(ptr.trim());  if (!m) {    return { have: false, block: 0, log: -1, raw: ptr, reason: "bad_format" };  }  return {    have: true,    block: parseInt(m[1], 10),    log: parseInt(m[2], 10),    raw: ptr  };}// Index fiable: logIndex si dispo, sinon transactionIndexfunction safeIndex(tx) {  let ix = tx && tx.logIndex;  if (    ix === undefined ||    ix === null ||    ix === "" ||    isNaN(parseInt(ix, 10))  ) {    ix = tx && tx.transactionIndex;  }  ix = parseInt(ix, 10);  if (isNaN(ix)) ix = 0;  return ix;}function trimZeros(s) {  if (s.indexOf(".") === -1) return s;  s = s.replace(/0+$/, "");  if (s.endsWith(".")) s = s.slice(0, -1);  return s;}// -------- Appel Etherscan --------async function fetchTokenTxs(vault) {  if (!ETHERSCAN_API_KEY) {    throw new Error("ETHERSCAN_API_KEY missing in .env");  }  const address = vault.vaultAddress;  const token = vault.tokenAddress;  const url =    `${ETHERSCAN_API_URL}?chainid=${CHAIN_ID}` +    `&module=account&action=tokentx` +    `&address=${address}` +    `&contractaddress=${token}` +    `&page=1&offset=100&sort=desc` +    `&apikey=${ETHERSCAN_API_KEY}`;  const res = await fetch(url);  if (!res.ok) {    console.error(      `‚ùå Etherscan HTTP error for ${vault.name}:`,      res.status,      await res.text()    );    return [];  }  const json = await res.json();  const rows = parseRows(json);  return rows;}// -------- Traitement d'un vault --------async function processVault(vault) {  const WATCH_ADDR_LC = vault.vaultAddress.toLowerCase();  const TOKEN_ADDR_LC = vault.tokenAddress.toLowerCase();  const TOKEN_DEFAULT_DECIMALS = vault.tokenDecimals || 18;  const MIN_AMOUNT = vault.minAmount || 0;  const TOKEN_SYMBOL = vault.tokenSymbol || "TOKEN";  const rows = await fetchTokenTxs(vault);  const key = `${WATCH_ADDR_LC}-${TOKEN_ADDR_LC}`;  const rawPtr = pointers.get(key) || "";  const p = parsePointer(rawPtr || "");  const out = [];  for (const tx of rows) {    const ca = (tx.contractAddress || "").toLowerCase();    if (ca !== TOKEN_ADDR_LC) continue;    const from = (tx.from || "").toLowerCase();    const to = (tx.to || "").toLowerCase();    // Ignore self-transfer    if (from === WATCH_ADDR_LC && to === WATCH_ADDR_LC) continue;    // Type relatif √† l'adresse suivie    let type = null;    if (to === WATCH_ADDR_LC) type = "Deposit";    else if (from === WATCH_ADDR_LC) type = "Withdraw";    if (!type) continue;    const block = parseInt(tx.blockNumber, 10) || 0;    const ix = safeIndex(tx);    // Anti-rafale 1er run: pas de pointeur valide => on n'envoie rien    const isNew =      p.have && (block > p.block || (block === p.block && ix > p.log));    if (!isNew) continue;    const dec =      parseInt(tx.tokenDecimal || TOKEN_DEFAULT_DECIMALS, 10) ||      TOKEN_DEFAULT_DECIMALS;    const sym = tx.tokenSymbol || TOKEN_SYMBOL;    const amountNum = Number(tx.value || "0") / Math.pow(10, dec);    if (amountNum < MIN_AMOUNT) continue;    const ts = Number(tx.timeStamp || "0") * 1000;    const when = new Date(ts).toISOString();    const amountStr = trimZeros(amountNum.toFixed(Math.min(dec, 8)));    out.push({      uid: block + ":" + ix,      type,      symbol: sym,      amount: amountStr,      from,      to,      hash: tx.hash,      time: when    });  }  // Tri ancien -> r√©cent  out.sort((a, b) => {    const [ab, al] = a.uid.split(":").map((x) => parseInt(x, 10));    const [bb, bl] = b.uid.split(":").map((x) => parseInt(x, 10));    if (ab !== bb) return ab - bb;    return al - bl;  });  // Nouveau pointeur: bloc le + r√©cent + max index observ√© sur ce bloc  let newPointer = rawPtr || "";  if (rows.length) {    const topBlock = parseInt(rows[0].blockNumber, 10) || 0;    let maxIx = 0;    for (const r of rows) {      const b = parseInt(r.blockNumber, 10) || 0;      if (b !== topBlock) break; // rows tri√© desc      const sIx = safeIndex(r);      if (sIx > maxIx) maxIx = sIx;    }    newPointer = topBlock + ":" + String(maxIx);  }  pointers.set(key, newPointer);  // Construction des messages Telegram (HTML)  for (const it of out) {    const directionEmoji = it.type === "Deposit" ? "üü¢" : "üî¥";    const msg =      `<b>${directionEmoji} ${it.type} ${it.symbol}</b> on <b>${vault.name}</b>\n` +      `Amount: <b>${it.amount} ${it.symbol}</b>\n` +      `From: <code>${it.from}</code>\n` +      `To: <code>${it.to}</code>\n` +      `Date: ${it.time}\n` +      `Tx: https://etherscan.io/tx/${it.hash}`;    await sendTelegramMessage(chatId, msg);  }  const debug = {    vault: vault.name,    pointerIn: rawPtr,    pointerValid: p.have,    pointerParsed: p.have ? `${p.block}:${p.log}` : "(none)",    topBlock: rows.length ? String(rows[0].blockNumber) : "",    rowsCount: rows.length,    newItems: out.length,    newPointer  };  console.log("üîé Debug vault:", debug);}// -------- Boucle principale --------async function tickAllVaults() {  for (const vault of VAULTS) {    try {      await processVault(vault);    } catch (err) {      console.error(`‚ùå Error processing vault ${vault.name}:`, err);    }  }}export function startVaultsTracker() {  console.log(    `üöÄ gami-vaults-tracker-bot started. Check every ${CHECK_INTERVAL_SECONDS}s.`  );  // 1er run : il met juste les pointeurs √† jour (pas de msgs si pointer vide)  tickAllVaults();  // Puis check p√©riodique  setInterval(tickAllVaults, CHECK_EVERY_MS);}